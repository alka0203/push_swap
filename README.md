# PUSH SWAP

Push swap, to put in a general perspective, is a project based on the sorting of a random list of numbers within a limited number of commands.

Whilst being provided with a set of command instructions that are available to use freely as needed, the project involves us to create the commands ourselves and think of an optimized logic that may allow you to sort the set of numbers in the least number of moves possible. The most commonly used basis for this project would either be arrays or linked lists. Perhaps, doubly linked lists would ease the process much more for someone who wishes to begin the project, however, in this case, I decided to start with singular linked lists.

To give a further bit more insight into how push swap works, the user enters any argument of numbers into the command line. In my case, I take care of all possible inputs into consideration; if it is a non numerical value or duplicated values within the set of numbers inputed, an error message will appear. However, for the main part, the user has the ability to either input each number as one argument, as one argument with multiple numbers in a string or both. Once all the proper checks have been performed, the numbers from the command line are added to your stack A (that is if the numbers are unsorted, else, the program comes to an end). 

Moving onto the next stage, I have created three functions to sort the list of numbers:
1. **sort_small**: this function sorts numbers that are smaller of equal to three as there are only a specific number of cases in the ways that they can be unsorted, and so it is brute forced depending on whether the number above is smaller of bigger than the one below.
2. **sort_five**: in this case I sort the lists with either five or four numbers. The way I perform this is by creating a seperate array with the given list of unsorted numbers and use any sorting algorithm that one may be accustomed to, in my case I have used bubblesort. Using the sorted array, I compare with my unsorted list and leave the three smallest numbers in stack A while moving the rest to stack B. Once this is done, I take use of my `sort_small` function on both stacks. At this point, the sets of numbers are both sorted in an ascending order and so the remaining the numbers in stack B, I move it over to stack A one by one while rotating it downwards, resulting in a perfectly sorted list.
3. **sort_big**: this function is used for every number that is greater than 5. So now in this case, likewise of sort_five, I have a seperate sorted array of the given list using bubblesort. However, unlike the previous function, there are two main cases. One is for numbers that are less than or equal to 100 and the second one would be for all other cases. For the former set of cases, I introduce a divider of four; this would divide the bubblesorted array in four and compare all the numbers in stack A from the top and bottom for the first quarter of smallest numbers. As it is a range of numbers, whichever number that you encounter first from the top or bottom that requires least moves to be pushed to the top of stack A will be moved and then pushed over to stack B. Once the range of twenty five percent is are all pushed over to the latter stack, the process keeps repeating. Hence, the previous bubblesorted array is freed and a new one is created where with the remaining sets of numbers until there are just three numbers left in stack A. Once again, using the `sort_small` function to sort those remaining numbers. For all numbers greater than hundred, I use the exact same process with the slight variation of the divider being 8 rather than 4.
    - This brings us to the second part of the function, sub function, `sort_last`. So at this point, most of the numbers are semi-sorted in stack B; as the list of range of numbers kept progressively decreasing, the different chunks in stack B are therefore progressively sorted as you move up the stack. The method that I have used to move all the numbers back to stack A is through a similar method. Once again, a bubblesorted array is created. however, unlike the previous the method, there does not reacha point when the array has to be created again. One array is used for the entire duration of the function. So the main concept is to look for the highest number in stack B, move it to the top of the stack and push it over to stack A. As the remaining the numbers were already the last three highest number, every new number being pushed over would be placed directly on top of one another. This ensure that no other additional steps would be required in stack A as the numbers are consequently being placed in ascending order.

The reason that I have seperate functions for each sets of those numbers is beacuse the project requires the for 3, 5, 100 and 500 numbers in a stack to be listed within a specific range of moves. As a matter of face, all sets of numbers would perfectly work with the sort_big function, however, the efficiency would be much lower.

To end it all, the whole program ends once all the numbers in stack A are completely sorted in ascending order.

Push_swap is definitely a challenging project that forces you to test all of your limits and you may end up creating your functions over and over trying to find the most optimized pathway to solve the entire project. Regardless of how frustrating it may become, it teaches you a great deal of ways to start your work with a clear and properly approached mindset.



>The best way to visualize this project and make sense of how exactly your code moves about the commands would be by using the [Push_swap visualizer] (https://github.com/alka0203/push_swap_visualizer)